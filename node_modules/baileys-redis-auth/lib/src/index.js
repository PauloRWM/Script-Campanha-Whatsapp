"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteKeysWithPattern = exports.useRedisAuthState = exports.deleteHSetKeys = exports.useRedisAuthStateWithHSet = void 0;
const ioredis_1 = __importDefault(require("ioredis"));
const baileys_1 = require("@whiskeysockets/baileys");
const createKey = (key, prefix) => `${key}:${prefix}`;
const useRedisAuthStateWithHSet = async (redisOptions, prefix = 'DB1') => {
    const redis = new ioredis_1.default(redisOptions);
    redis.on('connect', async () => {
        const redisClientName = `baileys-auth-${prefix}`;
        await redis.client('SETNAME', redisClientName);
        console.log(`Redis client name set to ${redisClientName}`);
    });
    const writeData = (key, field, data) => redis.hset(createKey(key, prefix), field, JSON.stringify(data, baileys_1.BufferJSON.replacer));
    const readData = async (key, field) => {
        const data = await redis.hget(createKey(key, prefix), field);
        return data ? JSON.parse(data, baileys_1.BufferJSON.reviver) : null;
    };
    const creds = (await readData('authState', 'creds')) || (0, baileys_1.initAuthCreds)();
    return {
        state: {
            creds,
            keys: {
                get: async (type, ids) => {
                    const data = {};
                    await Promise.all(ids.map(async (id) => {
                        const value = await readData('authState', `${type}-${id}`);
                        data[id] =
                            type === 'app-state-sync-key' && value
                                ? baileys_1.proto.Message.AppStateSyncKeyData.fromObject(value)
                                : value;
                    }));
                    return data;
                },
                set: async (data) => {
                    const pipeline = redis.pipeline();
                    for (const category in data) {
                        for (const id in data[category]) {
                            const field = `${category}-${id}`;
                            const value = data[category][id];
                            if (value) {
                                pipeline.hset(createKey('authState', prefix), field, JSON.stringify(value, baileys_1.BufferJSON.replacer));
                            }
                            else {
                                pipeline.hdel(createKey('authState', prefix), field);
                            }
                        }
                    }
                    await pipeline.exec();
                },
            },
        },
        saveCreds: async () => {
            await writeData('authState', 'creds', creds);
        },
        redis,
    };
};
exports.useRedisAuthStateWithHSet = useRedisAuthStateWithHSet;
const deleteHSetKeys = async ({ redis, key }) => {
    try {
        console.log('removing authState keys', key);
        await redis.del(createKey('authState', key));
    }
    catch (err) {
        console.log('Error deleting keys:', err.message);
    }
};
exports.deleteHSetKeys = deleteHSetKeys;
const useRedisAuthState = async (redisOptions, prefix = 'DB1') => {
    var _a;
    const redis = new ioredis_1.default(redisOptions);
    const writeData = async (data, key) => {
        await redis.set(`${prefix}:${key}`, JSON.stringify(data, baileys_1.BufferJSON.replacer));
    };
    const readData = async (key) => {
        const data = await redis.get(`${prefix}:${key}`);
        return data ? JSON.parse(data, baileys_1.BufferJSON.reviver) : null;
    };
    const creds = (_a = (await readData('creds'))) !== null && _a !== void 0 ? _a : (0, baileys_1.initAuthCreds)();
    return {
        state: {
            creds,
            keys: {
                get: async (type, ids) => {
                    const promises = ids.map((id) => readData(`${type}-${id}`));
                    const values = await Promise.all(promises);
                    return ids.reduce((acc, id, index) => {
                        const value = values[index];
                        if (value) {
                            acc[id] =
                                type === 'app-state-sync-key'
                                    ? baileys_1.proto.Message.AppStateSyncKeyData.fromObject(value)
                                    : value;
                        }
                        return acc;
                    }, {});
                },
                set: async (data) => {
                    const pipeline = redis.pipeline();
                    for (const category in data) {
                        for (const id in data[category]) {
                            const value = data[category][id];
                            const key = `${prefix}:${category}-${id}`;
                            value
                                ? pipeline.set(key, JSON.stringify(value, baileys_1.BufferJSON.replacer))
                                : pipeline.del(key);
                        }
                    }
                    await pipeline.exec();
                },
            },
        },
        saveCreds: async () => {
            await writeData(creds, 'creds');
        },
        redis,
    };
};
exports.useRedisAuthState = useRedisAuthState;
const deleteKeysWithPattern = async ({ redis, pattern, }) => {
    let cursor = 0;
    do {
        const [nextCursor, keys] = await redis.scan(cursor, 'MATCH', pattern, 'COUNT', 100);
        cursor = parseInt(nextCursor, 10);
        if (keys.length > 0) {
            await redis.unlink(...keys);
            console.log(`Deleted keys: ${keys}`);
        }
    } while (cursor !== 0);
};
exports.deleteKeysWithPattern = deleteKeysWithPattern;
